@(action: play.api.mvc.Call, questionFrame: models.quiz.QuestionFrame, answerJson : controllers.quiz.AnswerJson, mathJsParser: String = "ARTC.mathJS.defaultParser")(implicit request: Request[AnyContent])

@import helper._
@import com.artclod.play._
@import controllers.quiz.AnswerCreate
@import controllers.quiz.AnswerCreate.answerFormat
@import controllers.quiz.AnswerCreate.choiceIndex
@import controllers.quiz.AnswerCreate.functionRaw
@import controllers.quiz.AnswerCreate.correct
@import controllers.quiz.AnswerJson.correctUnknown
@import controllers.quiz.AnswerJson.correctNo
@import controllers.quiz.AnswerJson.correctBlank

<section id="answer-editor">

    <h4> Answer the question section@s(questionFrame.sections). When you are done hit the "Answer" Button: </h4>

    <h5> @questionFrame.question.title </h5>

    <section id="answer-editor">
    @questionFrame.question.descriptionHtml

    @* ===== START SECTION ==== *@
    @for(sectionFrame <- questionFrame.sections.zipWithIndex) {
    @defining("$root." + AnswerCreate.sections + "()[" + sectionFrame._2 + "]") { viewModelSec =>
    <section>
    @sectionFrame._1.section.explanationRaw

    correct: <div data-bind="text: @{viewModelSec}.@{correct}"> </div>

    <div data-bind="visible : @{viewModelSec}.@{correct}() == @{correctUnknown}"> This is section is unknown</div>
    <div data-bind="visible : @{viewModelSec}.@{correct}() == @{correctNo}"> This is section is wrong</div>
    <div data-bind="visible : @{viewModelSec}.@{correct}() == @{correctBlank}"> This is section is blank</div>

        @* ===== START PARTS ==== *@
        @sectionFrame._1.parts match {

        case Left(parts) => { @for(part <- parts.zipWithIndex) {

        <div>
            <input type="radio" name="@{"s"+sectionFrame._2}" id="@{"s"+sectionFrame._2+"c"+part._2}" value="@part._2" data-bind="checked: @{viewModelSec}.@{choiceIndex}"> @{part._1.descriptionHtml} </input>
        </div>
        } }

        case Right(parts) => { @for(part <- parts.zipWithIndex) {
        @defining(viewModelSec + "." + AnswerCreate.functions + "()[" + part._2 + "]") { viewModelFunc =>
        <div>
            @part._1.descriptionHtml
            <input data-bind="value: @{viewModelFunc}.@{functionRaw}" />
            <span data-bind="attr: { 'id' : @{viewModelFunc}.id }"> not updated yet</span>

            <div data-bind="visible : @{viewModelFunc}.@{correct}() == @{correctUnknown}"> This is function is unknown</div>
            <div data-bind="visible : @{viewModelFunc}.@{correct}() == @{correctNo}"> This is function is wrong</div>
            <div data-bind="visible : @{viewModelFunc}.@{correct}() == @{correctBlank}"> This is function is blank</div>
        </div>
        } } }

        }
        @* ===== END PARTS ==== *@
    </section>
    } }
    @* ===== END SECTION ==== *@

    @form(action, 'id -> "answerJsonForm", 'class -> "pure-form") {
        <fieldset>
            <input type="hidden" name="@AnswerCreate.answerJson" id="answerJson">
            <input type="button" class="pure-button" value="Answer" onclick="answerJsonFormSubmit()">
            @views.html.helper.CSRF.formField
        </fieldset>
    }
    </section>

    <script>
        answerJsonFormSubmit = function() {
            $("#answerJson").val(ko.mapping.toJSON(viewModel));
            $("#answerJsonForm").submit();
        }
    </script>
</section>

<script type="text/javascript">
    // Get the raw data into a var
    var data = @Html(answerFormat.writes(answerJson).toString)

    // Turn it into a view model
    var viewModel = ko.mapping.fromJS(data);

    // Enhance with the MathJAX computations/displays
    for(var si=0; si<viewModel.@{AnswerCreate.sections}().length; si++) {
        var sectionModel = viewModel.@{AnswerCreate.sections}()[si];

        // Create an id for this section
        sectionModel.id = "s"+si;

        for(var pi=0; pi<sectionModel.@{AnswerCreate.functions}().length; pi++) {
            var partModel = sectionModel.@{AnswerCreate.functions}()[pi];

            // Create an id for this part
            partModel.id = "s"+si+"f"+pi;

            // Set up the mathjax updates
            var func = partModel.@{AnswerCreate.functionRaw};
            func.subscribe(function (newValue) {
                var mathResult = @{mathJsParser}(newValue);
                ARTC.mathJax.updateById(partModel.id, ARTC.mathJax.tex(mathResult.node.toTex()));
                partModel.@{AnswerCreate.functionMath}(mathResult.content);
            });
        }
    }
    // then applying bindings
    ko.applyBindings(viewModel, document.getElementById("answer-editor"));
</script>
